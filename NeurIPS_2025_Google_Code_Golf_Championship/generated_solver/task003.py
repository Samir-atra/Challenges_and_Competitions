#!/usr/bin/env python3
"""
Solution for `data/task003.json`.
The pattern for this task is to find the smallest repeating vertical pattern
(motif) in the input grid. The output is generated by taking the original
input grid, changing its main color to the most common color in the output
of the first training example (blue -> red), and then appending the motif
(also color-swapped) to the bottom.
"""
from __future__ import annotations

import json
import sys
from pathlib import Path
from typing import Any, Optional
import numpy as np # type: ignore

TASK_NAME = "task003.json"


def find_task_file() -> Optional[Path]:
    script_dir = Path(__file__).parent
    candidates = [
        script_dir.parent.parent / "data" / TASK_NAME,
        Path.cwd() / "data" / TASK_NAME,
        script_dir / TASK_NAME,
        Path(TASK_NAME),
    ]
    for p in candidates:
        if p.exists():
            return p
    return None


def solve_grid(input_grid: np.ndarray) -> np.ndarray:
    """Applies the task's logic to a single grid."""
    h, _ = input_grid.shape
    
    # Find the smallest repeating vertical pattern (motif)
    motif_h = h
    for i in range(1, h // 2 + 1):
        if h % i == 0:
            is_repeating = True
            motif = input_grid[:i, :]
            for j in range(i, h, i):
                if not np.array_equal(motif, input_grid[j:j+i, :]):
                    is_repeating = False
                    break
            if is_repeating:
                motif_h = i
                break
    
    # If no perfect repeat, find the smallest partial repeat from the top
    if motif_h == h:
        for i in range(1, h // 2 + 1):
            if np.array_equal(input_grid[:i, :], input_grid[i:2*i, :]):
                motif_h = i
                break

    motif_to_append = input_grid[:motif_h, :]
    
    # Create the new grid by stacking
    output_grid = np.vstack((input_grid, motif_to_append))
    
    # Swap the color from blue (1) to red (2)
    output_grid[output_grid == 1] = 2
    return output_grid


def solve(task_obj: Any) -> Any:
    """Solves all examples in a task file."""
    if not isinstance(task_obj, dict) or ('train' not in task_obj and 'test' not in task_obj):
        return {"error": "Input is not a valid task object"}

    solution_obj = {}
    for key in ['train', 'test', 'arc-gen']:
        if key in task_obj:
            solved_examples = []
            for example in task_obj[key]:
                input_grid = np.array(example['input'])
                output_grid = solve_grid(input_grid)
                solved_examples.append({'input': example['input'], 'output': output_grid.tolist()})
            solution_obj[key] = solved_examples
    return solution_obj


def main() -> None:
    p = find_task_file()
    if not p:
        print(json.dumps({"task": TASK_NAME, "error": "file not found"}, ensure_ascii=False))
        sys.exit(2)

    obj = json.loads(p.read_text(encoding="utf-8"))
    solution = solve(obj)
    print(json.dumps({"task": p.name, "solution": solution}, ensure_ascii=False))


if __name__ == "__main__":
    main()
